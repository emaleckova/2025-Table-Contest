---
title: "Untitled"
format:
  html:
    embed-resources: true
    code-fold: true
    code-summary: "Show code"
    code-overflow: wrap



toc: true
toc-expand: true
number-sections: true

message: false
warning: false

echo: true
---


# Motivation

I am making this tutorial for some six years younger me. I was in the second year of graduate school, working on my first manuscripts and gaining first experiences with `R` - specifically, with analysis of mRNA-sequencing data and making first visualizations with the `{ggplot2}`. While it felt natural to create figures programmatically, I never considered this option for tables and unfortunately did not develop a lot in this regard by the time I was writing my thesis. Luckily, I discovered the `{gt}` package for my current job and can say:

> Who wants reproducible, well-documented work and matching visual elements should pay attention to the `{gt}` package.

My aim is to show that with the `{gt}` package, it is possible to create a minimalist summary tables ready for a publication (@-sec-publication-table), a small table accompanying a chart (@sec-xxxx) as well as visually advanced tables suitable - *e.g.*, for a poster - (@sec-poster-design) and even interactive tables - *e.g.*, for a laboratory/project website (@sec-interactive). For scientific topics, we may have special requirements such as italicized taxonomic names, use of subscripts or Greek characters. Thanks to `{gt}`'s inbuilt formatting options and support of `markdown` and `HTML` notions, all of these are easy tasks.

Ideally, our work on a bigger analysis or a project will be structured as an *R project* covering the entire pipeline from data preprocessing to exploratory analysis and to generation of outputs such as figures and tables. It is common to provide *supplementary materials* to a manuscript - for example, a table summarizing our data at a suitable level of detail. This is why @sec-appendix provides a little teaser on use of `{openxlsx2}` package

<!-- In  larger projects - *e.g.*, a scientific manuscript, a conference poster, or a report which belongs to a series of reports - it is desirable to use common visual elements, such as font family or institution colours. This will be considered when generating individual examples. -->

# Data

We will use the `vegetation` dataset available with the `{folio}` package. It is a collection of measurements of ^12^C and ^13^C isotopes in 32 plant familie of C~3~ and C~4~ species. The data was generated by [T. E. Cerling & J. M. Harris (1999)](https://link.springer.com/article/10.1007/s004420050868). 

**Isotopic discrimination**

Depending on the type of photosynthesis, different plant species show different level of discrimination between ^12^C and ^13^C (both stable) isotopes. In an experimental procedure, the ratio* in a sample (here, a green leaf of selected plant species) is compared to ratio in a standard and the difference is reported as parts per thousand: thus the notion δ^13^C. Plants preferentially take up the "light" ^12^C isotope over the "heavier" ^13^C isotopic, resulting in negative ratio. Species which evolved C~4~ of photosynthesis, however, take up ^13^C more frequently which is detectable as a less negative δ^13^C value. 

\* $δ \ ^{13}C = (\frac{ratio \ in \ sample}{ratio \ in \ standard} - 1) * 1000$

# Getting started

We need access to required packages and obviously to the data with will further work with. I like to load all packages right at beginning of the document for a convenient overview of all required dependencies. I will point out some of the packages when we need them later.

```{r}
#| label: session-setup
#| code-fold: false

# Data source
library(folio)

# Maps
library(rnaturalearth)

# Data wrangling, functional programming functions
library(dplyr)
library(purrr)

# Visualization
library(gt)
library(ggplot2)
library(showtext)
library(see) # half-violin plots
library(ggiraph)
library(htmltools)

# Table export
library(openxlsx2)
```


After loading the data, some preprocessing will be handy to avoid troubles and repetitive handling of the issues again and again. For example, in @sec-advanced-design we will draw in earth map data to visualize countries. It turnes out that the `{rnaturalearth}` packages which is a common source of geographical data refers to *Democratic Republic of the Congo*, while the authors of the original publication use older name *Zaire*. Besides making this fix, we will also introduce an abbreviated version of the current country's name to save some space in plot titles (also relevant in @sec-advanced-design). We will also introduce `C<sub>3</sub>` and `C<sub>4</sub>` in the `type` column to set us for a nicely formatted spelling throughout all tables.

```{r}
#| label: load-data

raw_dat_vegetation <- folio::vegetation

# Zaire was renamed in 1997
dat_vegetation <- raw_dat_vegetation |>
  mutate(
    country_label = case_when(
      country == "Zaire" ~ "Dem. Rep. of Congo",
      TRUE ~ country
    ),
    country = case_when(
      country == "Zaire" ~ "Democratic Republic of the Congo",
      TRUE ~ country
    )
  ) |> 
  # html for subscript in C3, C4
  mutate(type = case_when(
    type == "C3" ~ "C<sub>3</sub>",
    type == "C4" ~ "C<sub>4</sub>",
    TRUE ~ type
  ))
```

In some of the tables, we will refer to the data source in the table's footnote and we thus create a reusable footnote label early on. Note `markdown` syntax for bold and monospace text:

```{r}
#| label: common-elements

# Data source footnote
folio_footnote <- "**Data source:** `vegetation` data from the `{folio}` package"
```


# Publication design {#sec-publication-table}

Tables are common is scientific publications but usually rather minimalist design is preferred. Such tables are not only easy to read but also easy to create with the `{gt}` package - a perfect occasion for the first table of this tutorial. For the demonstration purposes, we will summarize δ^13^C measurement by families and countries.

```{r}
#| label: summarize-by-family-country

veg_summarized <- dat_vegetation |> 
    group_by(family, country, type) |>
    summarize(
      n_plants = n(), # number of underlying measurements
      mean_d = mean(delta),
      sd_d = sd(delta),
      ) |> 
    ungroup()
```

## Simplest table

Displaying a data frame as a `gt` table is a straightforward process and the default design is pleasing. However, our table will require some additional formatting to satisfy taxonomical and scietific conventions given by the data.

```{r}
#| label: tbl-deafults
#| code-fold: false

tbl_plain <- veg_summarized |> 
    gt()

tbl_plain
```


## Scientific and  other formatting

We will choose if there are any columns we would like to hide - here the `n_plants` which we introduced as helper column to control conditional formatting (in @sec-conditional-rows). We take advantage of `sub_missing()` function which helps us to handle missing values (`NA`s) according to our preference without the need to modify the input data directly or by introducing a helper column.

With `tab_style()` we can easily italicize an entire column and with `cols_label()` we can turn existing variable names into a meaningful and appealing column labels. When setting up a spanner over the numerical columns, we use `markdown` to achieve proper formatting. `fmt_number()` makes common number formatting options a simple task - we use to control number of decimal places.


```{r}
#| label: tbl-publication

tbl_formatted <- tbl_plain |>
    # this is only a helper column used for conditional formatting and it should not be displayed in the final table
    cols_hide("n_plants") |>
    # replace default NA values with a "-"
    # Note: modifying the data with {dplyr} functions would work equally well but {gt} has a devoted function for this purpose
    sub_missing(columns = "sd_d", missing_text = "-") |>
    tab_style(style = list(
        cell_text(style = "italic")),
    # family names in italics
    locations = cells_body(columns = "family")
    ) |> 
    # ^13^ is markdown for superscript, &delta is html for lower case Greek delta
    tab_spanner(columns = contains("_d"), label = md("&delta;^13^C")) |> 
    cols_label(
        family = "Family",
        country = "Country",
        type = "Type",
        mean_d = "Mean", 
        sd_d = "SD"
    ) |> 
    fmt_markdown(columns = c("type")) |> 
    fmt_number(columns = c("mean_d", "sd_d"), decimals = 2) |> 
    # basic formatting with the customized theme
    # Note: order matters here - the custom theme defines formatting for column spanners and it must be used only after a (all) spanner(s) were created
  cols_width(matches("family") ~ px(150),
             matches("country") ~ px(250),
             everything() ~ px(100))

tbl_formatted
```

## Custom theme

A publication may contain multiple figures. Instead of repeating the same code again and potentially making the same adjustments at multiple places if we decide to make changes to the table design, we can define a custom theme once. We use `{gt}` function and formatting options as with a regular table but wrap all of our code into a function. In our theme, we will define font family and size for individual components of the table. We will also ensure that column headings are displayed in bold font face.

```{r}
#| label: gt-publication-theme

paper_gt_theme <- function(gt_table) {
  gt_table |> 
    # overall aspects such as font and padding
    tab_options(
      table.font.names = "Times New Roman",
      data_row.padding = px(6),
      heading.align = "center",
      heading.title.font.size = px(26),
      heading.subtitle.font.size = px(14),
      table_body.hlines.width = px(0)
    ) |> 
    # column labels and spanners in bold font face
    tab_style(
        style = cell_text(weight = "bold"),
        locations = cells_column_labels(everything())
    ) |> 
    tab_style(
        style = cell_text(weight = "bold"),
        locations = cells_column_spanners(spanners = everything())
    )      
}
```


:::{.callout-warning}
## Custom theme placement

The custom scheme contains formatting options for column spanners and the theme definition **must** thus come only once spanner were defined. In other case, they will remain unaffected by the custom theme.
:::

```{r}
#| label: tbl-publication-themed

tbl_formatted |>
  paper_gt_theme()
```


## Conditional row formatting {#sec-conditional-rows}

We take the existing, formatted table a little further. In some families, the number of measured species was low and we will use this information for conditional formatting of the affected rows. We will also include a table footnote to explain the formatting right in place.

We stored the previous table as a gt table and we will take advantage of it. We can add additional formatting options to existing gt object which is more elegant and less error-prone than copy-pasting of longer pieces of code.

We take advantage of `n_plants` "helper column" to grey out families with less than three measurements, with `tab_footnote()` we can easily provide more details about meaning of the formatting options.

```{r}
#| label: tbl-publication-ready-conditional

tbl_publication_conditional <- tbl_formatted |>
  paper_gt_theme() |>
  # families with less than three measurements in grey
  tab_style(style = list(
    cell_text(color = "grey50")
    ),
    locations = cells_body(columns = everything(),
                           rows = n_plants < 3)
    ) |> 
  # conditional formatting was introduced and it should be explained - a table footnote is a good place to do so
  tab_footnote(footnote = md(paste(folio_footnote, "<br>", 
                                   "Families which have less than three measurements are greyed out.")))

tbl_publication_conditional 
```


## Default table processing by Quarto

:::{.callout-tip}
## Table processing in Quarto

Quarto, by default, applies a Bootstrap CSS class (`table-striped`) to tables generated from code chunks, which introduces row stripping in HTML tables. Row stripping is not common in publications and we thus turn it off in the code chunk below (with `html-table-processing: "none"`) to show how a final publication-ready table might look like.
:::

```{r}
#| label: tbl-publication-ready-conditional-stripped
#| html-table-processing: "none"

tbl_publication_conditional 
```


# Poster design {#sec-poster-design}

In other situations, we may be more creative with our table design. A well-done table can be as catchy as a figure and we can use it to get attention of our readers. In the course of this tutorial, we can think for example of a table for a scientific poster. The `vegetation` data contains details about countries where the δ^13^C measurements were done - highlighting the country's positions in continent shapes should be the eye catcher element of our table.

While working on @tbl-publication-ready-conditional, we realized that there was a different number of measurements in different families. In this section, we will group our data to even smaller numbers of groups and we do not want to loose the detail about the number of underlying data points. We will use `ggplot_image()` to include a scatter plot (combined with half-violin plots to visualize the distribution of measured values even better).

Besides combining table layout with `{ggplot2}` figures, we will pay attention to colours used in the various components of the table. In a real project, it may be for example organisation colours. Here, we will use a few colours from the `sPBIYlGn` palette from the `{Redmonder}` package.

We will start be loading the `{rnaturalearth}` package which - among many other details about countries - contains assignment of countries to continents and polygons for countries' borders.

```{r}
#| eval: false
library(rnaturalearth)
```

Next, we will proceed with some pre-processing:  
  1. extract labels (used as plot titles) of countries of interest (those with measurement data) as a named vector - the names are critical to match country names from `dat_vegetation` (and data frames derived from it) with country polygons from `{rnaturalearth}` (here, loaded as `world_data`)  
  2. obtain countries data  
  3. and subset them only to countries from the `vegetation` data set  

```{r}
# 1. Store country labels as a named vector
country_labels <- sort(unique(dat_vegetation$country_label))
names(country_labels) <- sort(unique(dat_vegetation$country))

# 2. Get countries data
world_data <- ne_countries(scale = "medium", returnclass = "sf")
# glimpse(world_data)

# 3. Subset countries data only for countries of interest

# Countries in the data
vegetation_countries <- unique(dat_vegetation$country)
vegetation_continents <- world_data[world_data$name_en %in% vegetation_countries, ]$continent

# Get their continents
vegetation_sf_continents <- world_data[world_data$continent %in% vegetation_continents, ]

# Subset the sf world data for countries of interest
vegetation_sf_countries <- world_data[world_data$name_en %in% vegetation_countries, ]
```


  4. define a custom font using `{showtext}` package

```{r}
#| label: set-custom-font

library(showtext)
font_add_google(name = "Open Sans", family = "open sans")
# showtext_auto is needed to display the font
showtext_auto()
```

:::{.callout-tip}
## Custom font for table and embeded figures

It is a good idea to define the custom font before proceeding with generation of the tables and embedded figures. This will allow us to reference to it when we create these building blocks.
:::

We will actually produce two figures for each country & plant type (either C~3~ or c ~4~) and as a next step, we will therefore prepare the code for both figures. Because we will use the `{gt}`'s `text_transform()` function to embed `ggplot2` figures into a table, we will wrap the plotting code into functions.

**Country plots**

This function takes a country name is argument and uses it to generate a map based on the `vegetation_sf_continents` object prepared earlier (it basically needs the country and continent polygons).

```{r}
#| label: fxn-plot-country

# Functions inputs are:
# country - character vector with name of the country to be highlighted

# Function relies on:
# vegetation_sf_countries - a combined sf + data.frame object with country coordinates and details; based on data from the {rnaturalearth} package

PlotCountry <- function(target_country) {
  # Get coordinates of the continent where target country is located
  target_continent <- vegetation_sf_countries[vegetation_sf_countries$name_en == target_country, ]$continent
  # Country label will be used a plot's title
  country_label <- country_labels[names(country_labels) == target_country]

  p_cont <- ggplot() +
    # entire continent
    geom_sf(data = vegetation_sf_continents[vegetation_sf_continents$continent == target_continent, ], fill = "white") +
    # highlight target country
    geom_sf(data = vegetation_sf_countries[vegetation_sf_countries$name_en == target_country, ], fill = "#1F6E5EFF") +
    labs(title = country_label) +
    # removes all grids, axes, etc.
    theme_void() +
    theme(plot.margin = margin(0, 0, 0, 0),
          plot.title = element_text(size = 32, hjust = 0.5),
          text = element_text(family = "open sans"))
  
  return(p_cont)
}
```

Let's give the function try with *Kenya* as an example:

```{r}
#| fig-width: 2

PlotCountry("Kenya")
```

**Observations and density**

The second figure should summarize observations for each country and type of plant. We will include all measurements as individual data points to give an impression about the size of each group. We will use a devoted `geom_jitter()` to give a little bit of random variation to the points, which is solely for visual purposes. (Note: `geom_point(position = "jitter")` would do the job as well.)

We will combine the scatter plot with half violin plot for an impression about distribution of the measure values. We will include y-axis to help our readers with interpretation of the plots. Nonetheless, we want to ensure that all figures will share the same axis limits to avoid any false interpretations.

```{r}
#| label: fxn-plot-dot-violins

### y-axis limits
# "nice" number are preferred and thus the use of modulo
# keep in mind that the measure values are negative!
y_min <- (round(min(dat_vegetation$delta) %% 10, 0) * 10) * -1
y_max <- (round(max(dat_vegetation$delta) %% 10, 0) * 10) * -1

### Function
PlotHalfViolins <- function(data_to_plot) {
  p_halfv <- ggplot(data_to_plot, aes(x = country, y = delta)) +
    geom_violinhalf(colour = "#005C55FF", fill = "#005C55FF", position = position_nudge(x = 0.15, y = 0)) +
    geom_jitter(aes(fill = type), colour = "#005C55FF", alpha = 0.8, width = 0.05) +
    scale_y_continuous(breaks = c(-10, -20, -30, -40)) +
    # set limits of the y axis
    coord_cartesian(ylim = c(y_min, y_max)) +
    theme_classic() +
    theme(
      plot.margin = margin(0, 0, 0, 0),
      plot.background = element_blank(),
      panel.background = element_blank(),
      axis.line.x = element_blank(),
      axis.line.y = element_line(colour = "black", linewidth = 1),
      axis.ticks.y = element_line(colour = "black", linewidth = 1),
      axis.ticks.x = element_blank(),
      axis.text.x = element_blank(),
      axis.text.y = element_text(colour = "black", size = 16),
      axis.title = element_blank(),
      aspect.ratio = 2,
      legend.position = "none"
    )

  return(p_halfv)
}
```

Again, let's see how the output of this function looks like:

```{r}
#| fig-width: 2

PlotHalfViolins(dat_vegetation[dat_vegetation$country == "Kenya", ])
```

Let's start with a very basic table - with all required building blocks but not much of customized design.

First of all, we will create a little summary table. It will be the basic scaffold to add the `{ggplot2}` components to. We will also calculate mean δ^13^C for each group of plants by their type AND country.

```{r}
#| label: summary-data

summarized_tbl_input <- dat_vegetation |>
  group_by(country, type) |>
  summarize(mean_d = mean(delta)) |>
  arrange(country)
```

Next, we will replace the country names with respective plots. We will use the `ggplot_image()` function in combination with `text_transform()` to replace a text (here, country name) with a `ggplot2` graphic created with our custom function.

```{r}
#| label: tbl-poster-design-intro
#| html-table-processing: "none"

summarized_tbl_input |> 
  gt() |>
  # country maps
  text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(y) {
        html(PlotCountry(y) |> ggplot_image(height = px(150), aspect_ratio = 1))
      })
    }
  )
```


`text_transform()` has done its job but the resulting table is not visually quite appealing. As we will work on improving it, we will first of all handle the "row groups". For most of the countries, there is only a single group of observations and we included country names in plot titles already. We can move row group labels to columns for a much nicer table

```{r}
#| label: tbl-poster-design-1
#| html-table-processing: "none"

summarized_tbl_input |> 
  gt(
    row_group_as_column = T,
  ) |>
  # country maps
  text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(y) {
        html(PlotCountry(y) |> ggplot_image(height = px(150), aspect_ratio = 1))
      })
    }
  )
```


Luckily, the `gt()` has a `process_md` argument which makes handling of subscript a super easy task:

```{r}
#| label: tbl-poster-design-2
#| html-table-processing: "none"

summarized_tbl_input |> 
  gt(
    rowname_col = "type",
    row_group_as_column = T,
    process_md = T
  ) |> 
  # country maps
  text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(y) {
        html(PlotCountry(y) |> ggplot_image(height = px(150), aspect_ratio = 1))
      })
    }
  )
```


Now, it's time to include the other figure, a combined jitter and half violin plot. Again, we can use `text_transform()` alongside with `ggplot_image()`. However, we need to "provide a new column" to place the graphic into. One option is the `mutate()` function from `{dplyr}` package. We can apply it just before passing our `summarized_tbl_input` into the `gt()` function without any need to really modify this input data.


```{r}
#| label: tbl-poster-design-3
#| html-table-processing: "none"

tbl_with_plots <- summarized_tbl_input |> 
  # new column for violin + scatter plot assembly
  mutate(violin_plot = "violin") |> 
  gt(
    rowname_col = "type",
    row_group_as_column = T,
    process_md = T
  ) |>
  # country maps
  text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(y) {
        html(PlotCountry(y) |> ggplot_image(height = px(150), aspect_ratio = 1))
      })
    }
  ) |>
  # half violin + dot plots
  text_transform(
    locations = cells_body(columns = "violin_plot"),
    fn = function(x) {
      # Use `map2` to iterate over the column and the row index simultaneously
      map2(x, 1:length(x), function(col_value, i) {
        # Get the row-specific country and type from the summarized data
        target_country <- summarized_tbl_input$country[i]
        target_type <- summarized_tbl_input$type[i]

        # Filter the original data and create the plot
        data_to_plot <- dat_vegetation |>
          filter(country == !!target_country, type == !!target_type)

        PlotHalfViolins(data_to_plot) |>
          ggplot_image(height = px(200)) |>
          html()
      })
    }
  )

tbl_with_plots
```


With that, our table's content is complete and we can try to improve it's overall design. There is a lot to do: nicer column labels (`cols_label()`) and formatting of numerical values (`fmt_number()`), alignment of column headers (`cols_align()`) and cell content (`tab_style()` targeting `cell_text()`)

```{r}
#| label: tbl-poster-design-4
#| html-table-processing: "none"

tbl_with_plots |> 
  fmt_number(columns = "mean_d", decimals = 2) |>
  tab_spanner(columns = contains(c("mean", "violin")), label = md("&delta;^13^C")) |>
  cols_label(
    type = "Type",
    mean_d = "Mean",
    violin_plot = "Measurements"
  ) |>
  cols_align(align = "center", columns = everything()) |> 
  tab_style(
    style = list(
      cell_text(align = "center")
    ),
    locations = cells_body(columns = everything())
  )
```

This is not too bad - but what about setting a nice background colour and adjusting cell borders accordingly? With predefined arguments of `tab_options()` and a little bit of CSS, we can do a lot with relatively little of a code. Even a gradient background!

```{r}
#| label: tbl-poster-design-final

tbl_with_plots_gradient <- summarized_tbl_input |> 
  mutate(violin_plot = "Violin") |> 
  gt(
    id = "countries_tbl",
    rowname_col = "type",
    row_group_as_column = T,
    process_md = T
  ) |> 
  # country maps
  text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(y) {
        html(PlotCountry(y) |> ggplot_image(height = px(150), aspect_ratio = 1))
      })
    }
  ) |> 
  # half violin + dot plots
  text_transform(
    locations = cells_body(columns = "violin_plot"),
    fn = function(x) {
      # Use `map2` to iterate over the column and the row index simultaneously
      map2(x, 1:length(x), function(col_value, i) {
        # Get the row-specific country and type from the summarized data
        target_country <- summarized_tbl_input$country[i]
        target_type <- summarized_tbl_input$type[i]

        # Filter the original data and create the plot
        data_to_plot <- dat_vegetation |>
          filter(country == !!target_country, type == !!target_type)

        PlotHalfViolins(data_to_plot) |>
          ggplot_image(height = px(200)) |>
          html()
      })
    }
  ) |> 
  fmt_number(columns = "mean_d", decimals = 2) |>
  tab_spanner(columns = contains(c("mean", "violin")), label = md("&delta;^13^C")) |>
  cols_label(
    type = "Type",
    mean_d = "Mean",
    violin_plot = "Measurements"
  ) |>
  cols_align(align = "center", columns = everything()) |> 
  tab_style(
    style = list(
      cell_text(align = "center")
    ),
    locations = cells_body(columns = everything())
  ) |> 
  tab_options(
    table.width = px(600),
    table.font.names = "open sans",
    heading.align = "center",
    column_labels.border.top.color = "white",
    column_labels.border.bottom.color = "white",
    heading.border.bottom.color = "white",
    table_body.border.top.color = "white",
    table_body.border.bottom.color = "white",
    table_body.hlines.color = "white",
    footnotes.border.bottom.color = "white"
  ) |>
  cols_width(
    type ~ px(100),
    mean_d ~ px(100)
  ) |> 
  opt_css(css ="
    #countries_tbl .gt_table {
      background: linear-gradient(180deg, #7DA37BFF, #DBD797);
    }
    
    #countries_tbl .gt_col_heading, #countries_tbl .gt_column_spanner_outer, #countries_tbl .gt_row.gt_center.gt_stub, #countries_tbl .gt_row.gt_center.gt_stub_row_group, #countries_tbl .gt_row.gt_left.gt_stub, #countries_tbl .gt_row.gt_left.gt_stub_row_group {
      background: transparent; border-right-style: none; vertical-align: middle;
    }")

tbl_with_plots_gradient
```


In case we would use the table as a stand-alone graphic, it is a good idea to include the data source and a little bit of detail about the data. We can do so with `tab_footnote()` (our predefined footnote label will come handy here) and `tab_header`.

```{r}
#| label: tbl-advanced-design-annotated

tbl_with_plots_gradient |> 
  tab_header(md("&delta;^13^C is a ratio between ^12^C and ^13^C isotopes; photosynthetically more efficient plant species show less negative values")) |> 
  tab_footnote(md(folio_footnote)) |> 
  tab_options(heading.title.font.size = 12,
              footnotes.font.size = 12)
```


# Interactive table {#sec-interactive}

A digital presentation of results offers more options to be creative, including interactive content (e.g., for for an organization or private website). We will thus transform the poster-ready @tbl-advanced-design-annotated into an interactive one. The interactive component will be the plots - we will display species names on hover over the individual data points. We will use the `{ggiraph}` package to achieve this.

```{r}
#| eval: false

library(ggiraph)
```

We will keep the chosen colour scheme and a visualization combining distribution with individual data points. We will however move from a half-violin plot to a standard violin plot and overlay the measurements (`geom_gitter()`) on top of it. This will give us more room to separate the data points from each other and our reader easier access to the species names.

The [ggiraph-book](https://www.ardata.fr/ggiraph-book/) is an excellent resource about the package and I am thus on purpose cutting this part short. In brief, we use the `_interactive` versions of common `{ggplot2}` geometries to add interactivity to a plot and display the result using the `girafe()` function. For fine tuning the resulting visualization, we can use `CSS`.

Let's use a subset of the `vegetation` data (C4 species of Kenya) while working on the code for an interactive scatter plot overlayed on a violin plot.

```{r}
#| label: fig-violin-plot

data_to_plot <- dat_vegetation |>
  filter(country == "Kenya", type == "C<sub>4</sub>")

p_violin <- ggplot(data_to_plot, aes(x = country, y = delta)) +
  geom_violin(colour = "#005C55FF", fill = "#005C55FF", alpha = 0.25) +
  geom_jitter_interactive(aes(tooltip = species), shape = 21, size = 3, fill = "#005C55FF", colour = "white") +
  scale_y_continuous(breaks = c(-10, -20, -30, -40)) +
  coord_cartesian(ylim = c(-45, -10)) +
  theme_classic() +
  theme(
    plot.margin = margin(0, 0, 0, 0),
    panel.background = element_blank(),
    plot.background = element_blank(),
    axis.line.x = element_blank(),
    axis.line.y = element_line(colour = "black", linewidth = 1),
    axis.ticks.y = element_line(colour = "black", linewidth = 1),
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_text(colour = "black", size = 16),
    axis.title = element_blank(),
    aspect.ratio = 3,
    legend.position = "none"
  )

girafe(
  ggobj = p_violin,
  height_svg = 2,
  width_svg = 2,
  options = "css = background-color: transparent;"
) |>
  girafe_options(
    opts_tooltip(css = "background-color: white; text-color: black; font-style: italic;")
  )
```


Once happy with the outcome, we again wrap the code in a function so that we can use it later with `text_transform()` as we have done in @sec-poster-design previously. However, we will be displaying an `HTML` content (an htmlwidget) this time. We can dealt with this by saving the ggraph plot into a temporary `HTML` file (`htmltools::save_html()`) which we can then "display" using base R `readLines()` function.


```{r}
#| eval: false

library(htmltools)
```


```{r}
#| label: fxn-ggiraph-dot-violins

PlotGirafeViolins <- function(data_to_plot){
  p_violin <- ggplot(data_to_plot, aes(x = country, y = delta)) +
    geom_violin(colour = "#005C55FF", fill = "#005C55FF", alpha = 0.25) +
    geom_jitter_interactive(aes(tooltip = species), shape = 21, size = 3, fill = "#005C55FF", colour = "white") +
    scale_y_continuous(breaks = c(-10, -20, -30, -40)) +
    coord_cartesian(ylim = c(-45, -10)) +
    theme_classic() +
    theme(
      plot.margin = margin(0, 0, 0, 0),
      panel.background = element_blank(),
      plot.background = element_blank(),
      axis.line.x = element_blank(),
      axis.line.y = element_line(colour = "black", linewidth = 1),
      axis.ticks.y = element_line(colour = "black", linewidth = 1),
      axis.ticks.x = element_blank(),
      axis.text.x = element_blank(),
      axis.text.y = element_text(colour = "black", size = 16),
      axis.title = element_blank(),
      aspect.ratio = 3,
      legend.position = "none"
    )

  g_violin <- girafe(
    ggobj = p_violin,
    width_svg = 1,
    height_svg = 1.5,
    options = "css = background-color: transparent;"
  ) |>
    girafe_options(
      opts_tooltip(css = "background-color: white; text-color: black; font-style: italic;")
    )

  # Save the ggiraph plot to a temporary HTML file
  tmpfile <- tempfile(fileext = ".html")
  save_html(g_violin, tmpfile)

  # Read the content of the HTML file as a single character string
  plot_html_content <- paste(readLines(tmpfile, warn = FALSE), collapse = "\n")

  return(plot_html_content)
}
```

In the overall table layout, we can apply all what we have learned before (grouping of rows, use of the `process_md argument`, modifying column labels, etc.), but the `text_transform()` call will become a little more complicated. First of all, we use summarized data `summarized_tbl_input` as a basis for the resulting table (input for the (`gt()` function). At the same time, we need access to the pre-processed, full-length data set (`dat_vegetation`) which is the input for our custom `PlotGirafeViolins()` function.

To generate the correct violin and scatter plot for each row of the resulting table, we: 

  - use `lapply()` to iterate over rows of the "summarized table"  
  - we keep track with the help of index `i` - this helps us to look up the corresponding `country` and `type` values from the `dat_vegetation` data frame  
  - the filtered data is input for our `PlotGirafeViolins()` function  
  - we send the output into `html()` to ensure proper rendering in the final table  

```{r}
#| label: text-transform-with-html
#| echo: true
#| eval: false

text_transform(
  locations = cells_body(columns = "violin_plot"),
  fn = function(x) {
    lapply(1:length(x), function(i) {
      target_country <- summarized_tbl_input$country[i]
      target_type <- summarized_tbl_input$type[i]

      data_to_plot <- dat_vegetation |>
      filter(country == target_country, type == target_type)

      # Call the modified plotting function and wrap in html()
      PlotGirafeViolins(data_to_plot) |>
        html()
    })
  }
)
```

And integrated with the remaining code, we get a table with known design and components but interactive charts:

```{r}
#| label: interactive-ggiraph

gt_giraph <- summarized_tbl_input |> 
  mutate(violin_plot = "") |>
  gt(
    id = "countries_tbl",
    rowname_col = "type",
    groupname_col = "country",
    row_group_as_column = T,
    process_md = T
  ) |>
  fmt_markdown(columns = "type") |>
  fmt_number(columns = "mean_d", decimals = 2) |>
  tab_header(md("&delta;^13^C is a ratio between ^12^C and ^13^C isotopes; photosynthetically more efficient plant species show less negative values")) |> 
  tab_spanner(columns = contains(c("mean", "violin")), label = md("&delta;^13^C")) |>
  cols_label(
    type = "Type",
    mean_d = "Mean",
    violin_plot = "Measurements"
  ) |>
  cols_align(align = "center", columns = everything()) |> 
  # country maps
  text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(y) {
        html(PlotCountry(y) |> ggplot_image(height = px(150), aspect_ratio = 1))
      })
    }
  ) |> 
  # text_transform for html
  text_transform(
    locations = cells_body(columns = "violin_plot"),
    fn = function(x) {
      lapply(1:length(x), function(i) {
        target_country <- summarized_tbl_input$country[i]
        target_type <- summarized_tbl_input$type[i]

        data_to_plot <- dat_vegetation |>
          filter(country == target_country, type == target_type)

        # Call the modified plotting function and wrap in html()
        PlotGirafeViolins(data_to_plot) |>
          html()
      })
    }
  ) |> 
  tab_style(
    style = list(
      cell_text(align = "center")
    ),
    locations = cells_body(columns = everything())
  ) |>
  tab_options(
    table.width = px(500),
    table.font.names = "open sans",
    heading.align = "center",
    column_labels.border.top.color = "white",
    column_labels.border.bottom.color = "white",
    heading.border.bottom.color = "white",
    table_body.border.top.color = "white",
    table_body.border.bottom.color = "white",
    table_body.hlines.color = "white",
    footnotes.border.bottom.color = "white"
  ) |>
  cols_width(
    type ~ px(100),
    mean_d ~ px(100)
  ) |> 
  opt_css(css ="
    #countries_tbl .gt_table {
      background: linear-gradient(180deg, #3F7F68, #DBD797);
    }
    
    #countries_tbl .gt_col_heading, #countries_tbl .gt_column_spanner_outer, #countries_tbl .gt_row.gt_center, #countries_tbl .gt_row.gt_center.gt_stub_row_group, #countries_tbl .gt_row.gt_left.gt_stub, #countries_tbl .gt_row.gt_left.gt_stub_row_group {
      background: transparent; border-right-style: none; vertical-align: middle;
    }
    
    #countries-tbl .girafe_container, #countries-tbl .girafe_container_std, #countries_tbl .ggiraph-svg, #countries-tbl .ggiraph-svg-bg {
      background: transparent;
    }
    
    #countries-tbl .gt_row_group_first{
      background: transparent;
    }") |>
  tab_footnote(md(folio_footnote))

final_html_output <- as_raw_html(gt_giraph,
  inline_css = TRUE
)
```


```{r}
#| label: tbl-interactive-gt
#| echo: true

gt_giraph
```


# Appendix: Creation of a supplementary table {#sec-appendix}

During data analysis for a publication (and other scientific outputs), we may want to share some of the intermediary outputs we have generated - for example, some summarized data may provided as a _supplementary material_ with our publication. We do not need to start from scratch - we simply proceed further with our project. There are probably multiple ways to achieve the goal of this section, we will  use `{openxlsx}` package.

```{r}
#| eval: false

library(openxlsx2)
```

1. We, fill create a new workbook and add a new sheet with defined name to it.

```{r}
#| label: create-worksheet

wbook <- wb_workbook()

wbook$add_worksheet("Table S1")
```

2. We will populate it with data. Before doing so, we will modify the input data frame a bit - for example, change column names and remove the `HTML` syntax fro the `type` column. We can also define number of decimal places.

```{r}
#| label: write-data

export_veg_summarized <- veg_summarized |>
  mutate(type = gsub("<sub>|</sub>", "", type))

export_veg_summarized <- export_veg_summarized |>
  rename(
    "mean delta" = mean_d,
    "SD delta" = sd_d,
    "N measurements" = n_plants
  )

wbook <- wbook$add_numfmt(
  sheet = 1,
  dims = wb_dims(
    # Target all rows from Row 2 (data) to the end
    rows = 2:(nrow(export_veg_summarized) + 1),
    cols = 5:6
  ),
  # Use the standard Excel number format for two decimal places
  numfmt = "0.000"
)

wbook$add_data("Table S1", export_veg_summarized)
```

3. We will introduce a minimal formatting to the data in workbook: column headers in bold and family names in italics.

```{r}
#| label: format-worksheet

wbook <- wbook$add_font(dims = wb_dims(rows = 1, cols = 1:ncol(export_veg_summarized)), bold = T)

wbook$add_font(dims = wb_dims(rows = 2:(nrow(export_veg_summarized) + 1), cols = 1), italic = T)
```

4. Finally, we can export the workbook into an `XLSX` file.

```{r}
#| label: save-xlsx

dir.create("outputs")

wb_save(wbook, file = "outputs/Supplementary_data.xlsx")
```


# Resources

Besides [ggiraph-book](https://www.ardata.fr/ggiraph-book/), [the `openxlsx2` book ](https://janmarvin.github.io/ox2-book/) and [`gt`'s documentation](https://gt.rstudio.com/), excelt and very helpful resources were:  

  - [R for the Rest of Us: How to Create Your Own Table Theme with the gt Package](https://rfortherestofus.com/2023/08/table-theme-gt)  
  - Albert Rapp's Creating beautiful tables in R with {gt}, particularly [chapter 2.6](https://gt.albert-rapp.de/fancy_stuff#add-arbitrary-plots-to-your-table) and [chapter 4.1.1](https://gt.albert-rapp.de/styling#tab-options)  
  - [Yan Holtz's Color Palette Finder](https://r-graph-gallery.com/color-palette-finder) - I picked colours from the `sPBIYlGn` colour palette  
  - Google Gemini to troubleshoot embedding of `ggiraph` objects into a `gt` table  