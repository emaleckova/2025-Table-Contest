---
title: "Untitled"
format:
  html:
    embed-resources: true
    code-fold: true
    code-summary: "Show code"
    code-overflow: wrap



toc: true
number-sections: true

message: false
warning: false

echo: true
---


# Motivation

I am making this tutorial for some six years younger me. I was in the second year of graduate school, working on my first manuscripts and gaining first experiences with `R` - specifically, with analysis of mRNA-sequencing data and making first visualizations with the `{ggplot2}`. While it felt natural to create figures programatically, I never considered this option for tables and unfortunately did not develop a lot in this regard by the time I was writing my thesis. Luckily, I discovered the `{gt}` package for my current job and can say:

> Who wants reproducible, well-documented work and matching visual elements should pay attention to the `{gt}` package.

My aim is to show that with the `{gt}` package, it is possible to create a minimalistic summary tables ready for a publication (@-sec-XXXXXXXXXXXXX), a small table accompanying a chart (@sec-BBBBBBBB) as well as visually advanced tables suitable - *e.g.*, for a poster - (@sec-YYYYYYYYYY) and even interactive tables - *e.g.*, for a laboratory/project website (@sec-ZZZZZZZZZZZZZ). For scientific topics, we may have special requirements such as italicized taxonommic names, use of subscripts or Greek characters. Thanks to `{gt}`'s inbuilt formatting options and support of `markdown` and `HTML` notions, all of these are easy tasks.

Ideally, our work on a bigger analysis or a project will be structured as an *R project* covering the entire pipeline from data preprocessing to exploratory analysis and to generation of outputs such as figures and tables. It is common to provide *supplementary materials* to a manuscript - for example, a table summarizing our data at a suitable level of detail. This is why @sec-AAAAAAAAAAA provides a little teaser on use of `{xxxxxxxx}` package

<!-- In  larger projects - *e.g.*, a scientific manuscript, a conference poster, or a report which belongs to a series of reports - it is desirable to use common visual elements, such as font family or institution colours. This will be considered when generating individual examples. -->

# Data

We will use the `vegetation` dataset available with the `{folio}` package. It is a collection of measurements of ^12^C and ^13^C isotopes in 32 plant familie of C~3~ and C~4~ species. The data was generated by [T. E. Cerling & J. M. Harris (1999)](https://link.springer.com/article/10.1007/s004420050868). 

**Isotopic discrimination**

Depending on the type of photosynthesis, different plant species show different level of discrimination between ^12^C and ^13^C (both stable) isotopes. In an experimental procedure, the ratio* in a sample (here, a green leaf of selected plant species) is compared to ratio in a standard and the difference is reported as parts per thousand: thus the notion δ^13^C. Plants preferentially take up the "light" ^12^C isotope over the "heavier" ^13^C isotopic, resulting in negative ratio. Species which evolved C~4~ of photosynthesis, however, take up ^13^C more frequently which is detectable as a less negative δ^13^C value. 

\* $δ \ ^{13}C = (\frac{ratio \ in \ sample}{ratio \ in \ standard} - 1) * 1000$

# Getting started

We need access to required packages and obviously to the data with will further work with. I like to load all packages right at beginning of the document for a convenient overview of all required dependencies. I will point out some of the packages when we need them later.

```{r}
#| label: session-setup
#| code-fold: false

# Data source
library(folio)

# Maps
library(rnaturalearth)

# Data wrangling, functional programming functions
library(dplyr)
library(purrr)

# Visualization
library(gt)
library(ggplot2)
library(showtext)
library(see) # half-violin plots
library(htmlwidgets)
```


After loading the data, some preprocessing will be handy to avoid troubles and repetitive handling of the issues again and again. For example, in @sec-advanced-design we will draw in earth map data to visualize countries. It turnes out that the `{rnaturalearth}` packages which is a common source of geographical data refers to *Democratic Republic of the Congo*, while the authors of the original publication use older name *Zaire*. Besides making this fix, we will also introduce an abbreviated version of the current country's name to save some space in plot titles (also relevant in @sec-advanced-design). We will also introduce `C<sub>3</sub>` and `C<sub>4</sub>` in the `type` column to set us for a nicely formatted spelling throughout all tables.

```{r}
#| label: load-data

raw_dat_vegetation <- folio::vegetation

# Zaire was renamed in 1997
dat_vegetation <- raw_dat_vegetation |>
  mutate(
    country_label = case_when(
      country == "Zaire" ~ "Dem. Rep. of Congo",
      TRUE ~ country
    ),
    country = case_when(
      country == "Zaire" ~ "Democratic Republic of the Congo",
      TRUE ~ country
    )
  ) |> 
  # html for subscript in C3, C4
  mutate(type = case_when(
    type == "C3" ~ "C<sub>3</sub>",
    type == "C4" ~ "C<sub>4</sub>",
    TRUE ~ type
  ))
```

In some of the tables, we will refer to the data source in the table's footnote and we thus create a reusable footnote label early on. Note that `markdown` syntax for bold text was used:

```{r}
#| label: common-elements

# Data source footnote
folio_footnote <- "**Data source:** `vegetation` data from the `{folio}` package"
```

## Definition of visual elements

```{r}
#| label: common-visuals

paper_gt_theme <- function(gt_table) {
  gt_table |> 
    # overall aspects such as font and padding
    tab_options(
      table.font.names = "Times New Roman",
      data_row.padding = px(6),
      heading.align = "center",
      heading.title.font.size = px(26),
      heading.subtitle.font.size = px(14),
      table_body.hlines.width = px(0)
    ) |> 
    # column labels and spanners in bold fontface
    tab_style(
        style = cell_text(weight = "bold"),
        locations = cells_column_labels(everything())
    ) |> 
    tab_style(
        style = cell_text(weight = "bold"),
        locations = cells_column_spanners(spanners = everything())
    )      
}
```


# Publication design {#sec-publication-table}

Tables are common is scientific publications but usually rather minimalistic design is prefered. Such tables are not only easy to read but also easy to create with the `{gt}` package - a perfect occasion for the first table of this tutorial. For the demonstration purposes, we will summarize δ^13^C measurement by families and countries.

```{r}
#| label: summarize-by-family-country

veg_summarized <- dat_vegetation |> 
    group_by(family, country, type) |>
    summarize(
      n_plants = n(), # number of underlying measurements
      mean_d = mean(delta),
      sd_d = sd(delta),
      ) |> 
    ungroup()
```

For a publication-ready table, we take advantage of `sub_missing()` function which helps us to handle missing values (`NA`s) according to our preference without the need to modify the input data directly or by introducing a helper column. With `tab_style()` we can easily italicize an entrie column and with `cols_label()` we can turn existing variable names into a meaningful and appealing column labels. When setting up a spanner over the numerical columns, we use `markdown` to achieve proper formatting. `fmt_number()` makes common number formatting options a simple task - we use to control number of decimal places.

Finally, we take advantage of our custom theme defined earlier. It comes as the last addition to the table's formatting. It is my general preference but in this case, the placement is also critical:

:::{.callout-warning}
## Custom scheme placement

The custom scheme contains formating options for column spanners and the theme definition **must** thus come only once spanner were defined. In other case, they will remain unaffected by the custom theme.
:::


```{r}
#| label: tbl-publication-ready
#| code-fold: false

tbl_publication <- veg_summarized |> 
    gt(id = "summary_tbl") |>
    # this is only a helper column used for conditional formatting and it should not be displayed in the final table
    cols_hide("n_plants") |>
    # replace default NA values with a "-"
    # Note: modifying the data with {dplyr} functions would work equally well but {gt} has a devoted function for this purpose
    sub_missing(columns = "sd_d", missing_text = "-") |>
    tab_style(style = list(
        cell_text(style = "italic")),
    # family names in italics
    locations = cells_body(columns = "family")
    ) |> 
    # ^13^ is markdown for superscript, &delta is html for lower case Greek delta
    tab_spanner(columns = contains("_d"), label = md("&delta;^13^C")) |> 
    cols_label(
        family = "Family",
        country = "Country",
        type = "Type",
        mean_d = "Mean", 
        sd_d = "SD"
    ) |> 
    fmt_markdown(columns = c("type")) |> 
    fmt_number(columns = c("mean_d", "sd_d"), decimals = 2) |> 
    # basic formatting with the customized theme
    # Note: order matters here - the custom theme defines formatting for column spanners and it must be used only after a (all) spanner(s) were created
  cols_width(matches("family") ~ px(150),
             matches("country") ~ px(250),
             everything() ~ px(100)) |> 
    paper_gt_theme()

tbl_publication
```


## Conditional row formatting

We take the existing simple table a little further. In some families, the number of measured species was low and we will use this information for conditional formatting of the affected rows. We will also include a table footnote to explain the formatting right in place.

We stored the previous table as a gt table and we will take advantage of it. We can add additional formatting options to existing gt object which is more elegant and less error-prone than copy-pasting of longer pieces of code.

We take advantage of `n_plants` "helper column" to grey out families with less than three measurements, with `tab_footnote()` we can easily provide more details about meaning of the formatting options.

```{r}
#| label: tbl-publication-ready-conditional

tbl_publication_conditional <- tbl_publication |> 
    # families with less than three measurements in grey
    tab_style(style = list(
        cell_text(color = "grey50")
    ),
    locations = cells_body(columns = everything(),
    rows = n_plants < 3)
    ) |> 
    # conditional formatting was introduced and it should be explained - a table footnote is a good place to do so
    tab_footnote(footnote = md(paste(folio_footnote, "<br>", 
                                  "Families which have less than three measurements are greyed out.")))

tbl_publication_conditional 
```


## Default table processing by Quarto

:::{.callout-tip}
## Table processing in Quarto

Quarto, by default, applies a Bootstrap CSS class (`table-striped`) to tables generated from code chunks, which introduces row stripping in HTML tables. Row stripping is not common in publications and we thus turn it off in the code chunk below (with `html-table-processing: "none"`) to show how a final publication-ready table might look like.
:::

```{r}
#| label: tbl-publication-ready-conditional-stripped
#| html-table-processing: "none"

tbl_publication_conditional 
```


# Advanced design {#sec-advanced-design}

In other situations, we may be more creative with our table design. A well-done table can be as catchy as a figure and we can use it to get attention of our readers. In the course of this tutorial, we can think for example of a table for a scientific poster. The `vegetation` data contains details about countries where the δ^13^C measurements were done - highlighting the country's positions in continent shapes should be the eye catcher element of our table.

While working on @tbl-publication-ready-conditional, we realized that there was a different number of measurements in different families. In this section, we will group our data to even smaller numbers of groups and we do not want to loose the detail about the number of underlying datapoints. We will use `ggplot_image()` to include a scatter plot (combined with half-violin plots to visualize the distirbution of measured values even better).

Next, we will pay attention to colours used in the various components of the table. In a real project, it may be for example organisation colours.

`rnaturalearth`

```{r}
library(rnaturalearth)
```


```{r}
#| label: generate-continent-shapes
#| results: hide

# store as named vector
country_labels <- sort(unique(dat_vegetation$country_label))
names(country_labels) <- sort(unique(dat_vegetation$country))

# ------ Prepare countries  - contiennts data -------------------------------------------------
world_data <- ne_countries(scale = "medium", returnclass = "sf")
# head(world_data)

# ----- Identify countries and continents needed ----------------------------------------------

# Countries in the data
vegetation_countries <- unique(dat_vegetation$country)
vegetation_continents <- world_data[world_data$name_en %in% vegetation_countries, ]$continent

# Get their continents
vegetation_sf_continents <- world_data[world_data$continent %in% vegetation_continents, ]

# Subset the sf world data for countries of interest
vegetation_sf_countries <- world_data[world_data$name_en %in% vegetation_countries, ]

# # ----- Plot continents with countries --------------------------------------------------------
# 
# # individual plots will be collected in this list
# p_ls_countries <- list()
# 
# for (country in vegetation_countries) {
#     # Countries with data on this continent
#     target_continent <- vegetation_sf_countries[vegetation_sf_countries$name_en == country , ]$continent
# 
#     p_cont <- ggplot() +
#         geom_sf(data = vegetation_sf_continents[vegetation_sf_continents$continent == target_continent, ], fill = "white") +
#         geom_sf(data = vegetation_sf_countries[vegetation_sf_countries$name_en == country, ], fill = "blue") +
#         theme_void()
# 
#     # save in the last, use country name as a label
#     p_ls_countries[[country]] <- p_cont
# }
```


```{r}
#| label: fxn-plot-country

# Functions inputs are:
# country - character vector with name of the country to be highlighted

# Function relies on:
# vegetation_sf_countries - a combined sf + data.frame object with country coordinates and details; based on data from the {rnaturalearth} package

PlotCountry <- function(target_country) {
  # Countries with data on this continent
  target_continent <- vegetation_sf_countries[vegetation_sf_countries$name_en == target_country, ]$continent
  
  country_label <- country_labels[names(country_labels) == target_country]

  p_cont <- ggplot() +
    geom_sf(data = vegetation_sf_continents[vegetation_sf_continents$continent == target_continent, ], fill = "white") +
    geom_sf(data = vegetation_sf_countries[vegetation_sf_countries$name_en == target_country, ], fill = "#1F6E5EFF") +
    labs(title = country_label) +
    theme_void() +
    theme(text = element_text(family = "serif"),
          plot.title = element_text(size = 24, hjust = 0.5))
  
  return(p_cont)
}
```


```{r}
#| label: fxn-plot-dot-violins

PlotHalfViolins <- function(data_to_plot) {
  p_halfv <- ggplot(data_to_plot, aes(x = country, y = delta)) +
    geom_violinhalf(colour = "#005C55FF", fill = "#005C55FF", position = position_nudge(x = 0.15, y = 0)) +
    geom_jitter(aes(fill = type), colour = "#005C55FF", alpha = 0.8, width = 0.05) +
    scale_y_continuous(breaks = c(-10, -20, -30, -40)) +
    coord_cartesian(ylim = c(-45, -10)) +
    theme_classic() +
    theme(
      plot.margin = margin(0, 0, 0, 0),
      plot.background = element_blank(),
      panel.background = element_blank(),
      axis.line.x = element_blank(),
      axis.line.y = element_line(colour = "black", linewidth = 1),
      axis.ticks.y = element_line(colour = "black", linewidth = 1),
      axis.ticks.x = element_blank(),
      axis.text.x = element_blank(),
      axis.text.y = element_text(colour = "black", size = 16),
      axis.title = element_blank(),
      aspect.ratio = 2,
      legend.position = "none"
    )

  return(p_halfv)
}
```


```{r}
#| label: set-custom-font

library(showtext) # fonts
font_add_google(name = "Open Sans", family = "open sans")
showtext_auto()
```


```{r}
#| label: tbl-advanced-design

summarized_tbl_input <- dat_vegetation |>
  group_by(country, type) |>
  summarize(mean_d = mean(delta)) |>
  mutate(violin_plot = country) |>
  arrange(country)

summarized_tbl_input |> 
  gt(
    id = "countries_tbl",
    rowname_col = "type",
    groupname_col = "country",
    row_group_as_column = T,
    process_md = T
  ) |>
  fmt_markdown(columns = "type") |>
  fmt_number(columns = "mean_d", decimals = 2) |>
  tab_spanner(columns = contains(c("mean", "violin")), label = md("&delta;^13^C")) |>
  cols_label(
    type = "Type",
    mean_d = "Mean",
    violin_plot = "Measurements"
  ) |>
  cols_align(align = "center", columns = everything()) |> 
  # country maps
  text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(y) {
        html(PlotCountry(y) |> ggplot_image(height = px(150), aspect_ratio = 1))
      })
    }
  ) |>
  # half violin + dot plots
  text_transform(
    locations = cells_body(columns = "violin_plot"),
    fn = function(x) {
      # Use `map2` to iterate over the column and the row index simultaneously
      map2(x, 1:length(x), function(col_value, i) {
        # Get the row-specific country and type from the summarized data
        target_country <- summarized_tbl_input$country[i]
        target_type <- summarized_tbl_input$type[i]

        # Filter the original data and create the plot
        data_to_plot <- dat_vegetation |>
          filter(country == !!target_country, type == !!target_type)

        PlotHalfViolins(data_to_plot) |>
          ggplot_image(height = px(200)) |>
          html()
      })
    }
  ) |>
  tab_style(
    style = list(
      cell_text(align = "center")
    ),
    locations = cells_body(columns = everything())
  ) |>
  tab_options(
    table.width = px(600),
    table.font.names = "open sans",
    heading.align = "center",
    column_labels.border.top.color = "white",
    column_labels.border.bottom.color = "white",
    heading.border.bottom.color = "white",
    table_body.border.top.color = "white",
    table_body.border.bottom.color = "white",
    table_body.hlines.color = "white",
    footnotes.border.bottom.color = "white"
  ) |>
  cols_width(
    type ~ px(100),
    mean_d ~ px(100)
  ) |> 
  opt_css(css ="
    #countries_tbl .gt_table {
      background: linear-gradient(180deg, #7DA37BFF, #DBD797);
    }
    
    #countries_tbl .gt_col_heading, #countries_tbl .gt_column_spanner_outer, #countries_tbl .gt_row.gt_center.gt_stub, #countries_tbl .gt_row.gt_center.gt_stub_row_group, #countries_tbl .gt_row.gt_left.gt_stub, #countries_tbl .gt_row.gt_left.gt_stub_row_group {
      background: transparent; border-right-style: none; vertical-align: middle;
    }") |>
  tab_footnote(md(folio_footnote))
```



# Interactive table

Maybe you want to draw attention to results of your project or an upcoming presentation. Social media are powerful and an interactive table might be a good option, for example on an institution website.

Sorting, search function

```{r}
library(ggiraph)
```


```{r}
#| label: fxn-ggiraph-dot-violins

PlotGirafeViolins <- function(data_to_plot){
  p_violin <- ggplot(data_to_plot, aes(x = country, y = delta)) +
    geom_violin(colour = "#005C55FF", fill = "#005C55FF", alpha = 0.25) +
    geom_jitter_interactive(aes(tooltip = species), shape = 21, size = 3, fill = "#005C55FF", colour = "white") +
    scale_y_continuous(breaks = c(-10, -20, -30, -40)) +
    coord_cartesian(ylim = c(-45, -10)) +
    theme_classic() +
    theme(
      plot.margin = margin(0, 0, 0, 0),
      panel.background = element_blank(),
      plot.background = element_blank(),
      axis.line.x = element_blank(),
      axis.line.y = element_line(colour = "black", linewidth = 1),
      axis.ticks.y = element_line(colour = "black", linewidth = 1),
      axis.ticks.x = element_blank(),
      axis.text.x = element_blank(),
      axis.text.y = element_text(colour = "black", size = 16),
      axis.title = element_blank(),
      aspect.ratio = 3,
      legend.position = "none"
    )

  g_violin <- girafe(
    ggobj = p_violin,
    width_svg = 2,
    height_svg = 3.5,
    options = "css = background-color: transparent;"
  ) |>
    girafe_options(
      opts_tooltip(css = "background-color: white; text-color: black; font-style: italic;")
    )

  # Save the ggiraph plot to a temporary HTML file
  tmpfile <- tempfile(fileext = ".html")
  save_html(g_violin, tmpfile)

  # Read the content of the HTML file as a single character string
  plot_html_content <- paste(readLines(tmpfile, warn = FALSE), collapse = "\n")

  return(plot_html_content)
}
```


```{r}
library(htmltools)
```


```{r}
#| label: tbl-advanced-ggiraph

gt_giraph <- summarized_tbl_input |> 
  gt(
    id = "countries_tbl",
    rowname_col = "type",
    groupname_col = "country",
    row_group_as_column = T,
    process_md = T
  ) |>
  fmt_markdown(columns = "type") |>
  fmt_number(columns = "mean_d", decimals = 2) |>
  tab_spanner(columns = contains(c("mean", "violin")), label = md("&delta;^13^C")) |>
  cols_label(
    type = "Type",
    mean_d = "Mean",
    violin_plot = "Measurements"
  ) |>
  cols_align(align = "center", columns = everything()) |> 
  # country maps
  text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(y) {
        html(PlotCountry(y) |> ggplot_image(height = px(150), aspect_ratio = 1))
      })
    }
  ) |> 
  # Corrected text_transform
  text_transform(
    locations = cells_body(columns = "violin_plot"),
    fn = function(x) {
      lapply(1:length(x), function(i) {
        target_country <- summarized_tbl_input$country[i]
        target_type <- summarized_tbl_input$type[i]

        data_to_plot <- dat_vegetation |>
          filter(country == target_country, type == target_type)

        # Call the modified plotting function and wrap in html()
        PlotGirafeViolins(data_to_plot) |>
          html()
      })
    }
  ) |> 
  tab_style(
    style = list(
      cell_text(align = "center")
    ),
    locations = cells_body(columns = everything())
  ) |>
  tab_options(
    table.width = px(500),
    table.font.names = "open sans",
    heading.align = "center",
    column_labels.border.top.color = "white",
    column_labels.border.bottom.color = "white",
    heading.border.bottom.color = "white",
    table_body.border.top.color = "white",
    table_body.border.bottom.color = "white",
    table_body.hlines.color = "white",
    footnotes.border.bottom.color = "white"
  ) |>
  cols_width(
    type ~ px(100),
    mean_d ~ px(100)
  ) |> 
  opt_css(css ="
    #countries_tbl .gt_table {
      background: linear-gradient(180deg, #3F7F68, #DBD797);
    }
    
    #countries_tbl .gt_col_heading, #countries_tbl .gt_column_spanner_outer, #countries_tbl .gt_row.gt_center, #countries_tbl .gt_row.gt_center.gt_stub_row_group, #countries_tbl .gt_row.gt_left.gt_stub, #countries_tbl .gt_row.gt_left.gt_stub_row_group {
      background: transparent; border-right-style: none; vertical-align: middle;
    }
    
    #countries-tbl .girafe_container, #countries-tbl .girafe_container_std, #countries_tbl .ggiraph-svg, #countries-tbl .ggiraph-svg-bg {
      background: transparent;
    }
    
    #countries-tbl .gt_row_group_first{
      background: transparent;
    }") |>
  tab_footnote(md(folio_footnote))

final_html_output <- as_raw_html(gt_giraph,
  inline_css = TRUE
)

write(final_html_output, "interactive_table.html")
```


# Appendix: Creation of a supplementary table

Add ID to differentiate multiple specimens of the same species + location


# Resources

Besides package documentation, I found the following resources useful:
- [https://rfortherestofus.com/2023/08/table-theme-gt](https://rfortherestofus.com/2023/08/table-theme-gt)   
- https://gt.albert-rapp.de/fancy_stuff#add-arbitrary-plots-to-your-table  
- https://gt.albert-rapp.de/styling#tab-options
- sPBIYlGn colour palette (https://r-graph-gallery.com/color-palette-finder)
- Google Gemini for embeding of girafe objects into a gt table
