---
title: "Untitled"
format:
  html:
    embed-resources: true

message: false
warning: false

echo: true
code-fold: true
---


```{r}
#| label: session-setup

# Data source
library(folio)

# Maps
library(rnaturalearth)

# Data wrangling
library(dplyr)
library(purrr)

# Visualization
library(gt)
library(ggplot2)
library(see) # half-violin plots
```


```{r}
#| label: load-data

raw_dat_vegetation <- folio::vegetation

# Zaire was renamed in 1997
dat_vegetation <- raw_dat_vegetation |>
  mutate(
    country_label = case_when(
      country == "Zaire" ~ "Dem. Rep. of Congo",
      TRUE ~ country
    ),
    country = case_when(
      country == "Zaire" ~ "Democratic Republic of the Congo",
      TRUE ~ country
    )
  ) |> 
  # html for subscript in C3, C4
  mutate(type = case_when(
    type == "C3" ~ "C<sub>3</sub>",
    type == "C4" ~ "C<sub>4</sub>",
    TRUE ~ type
  ))

# store as named vector
country_labels <- sort(unique(dat_vegetation$country_label))
names(country_labels) <- sort(unique(dat_vegetation$country))

# Data source footnote
folio_footnote <- "**Data source:** `vegetation` data from the `{folio}` package"
```

# Motivation

I am making this tutorial for six year younger me. I was in the second year of graduate school, working on my first manuscripts and gaining first experiences with `R`, specifically analysis of RNA-sequencing data and making first visualizations with the `{ggplot2}`. While it felt natural to create figures programatically, I never considered this option for tables. And my mindset did not change two years later when writing my thesis. Over the past year, I have started to use the `{gt}` package and can say: Who wants reproducible, well-documented work should create also tables programatically. My aim is to show that this is possible and that the `{gt}` package has got all basic formatting options (and many I probably still do not know about) covered.

<!-- Demonstrate that gt is compatible with other packages / part of pipleine/report; and how powerful tables are. -->

# Introduction
Tables can serve different purposes: they can represent a full record of raw data (*e.g.*, measurements as in the `vegetation` dataset used in this tutorial) which comes as an appendix of a scientific manuscript, tables can be a stand-alone summary of the data, or a complementary piece of information alongside a chart. In this tutorial, we will generate an example of each, starting from the same input data.

In  larger projects - *e.g.*, a scientific manuscript, a conference poster, or a report which belongs to a series of reports - it is desirable to use common visual elements, such as font family or institution colours. This will be considered when generating individual examples.

**Data**
`vegetation` dataset available via the `{folio}` package
Original publication: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX


# Definition of visual elements

```{r}
#| label: common-visuals

paper_gt_theme <- function(gt_table) {
  gt_table |> 
    # overall aspects such as font and padding
    tab_options(
      table.font.names = "Times New Roman",
      data_row.padding = px(6),
      heading.align = "center",
      heading.title.font.size = px(26),
      heading.subtitle.font.size = px(14),
      table_body.hlines.width = px(0)
    ) |> 
    # column labels and spanners in bold fontface
    tab_style(
        style = cell_text(weight = "bold"),
        locations = cells_column_labels(everything())
    ) |> 
    tab_style(
        style = cell_text(weight = "bold"),
        locations = cells_column_spanners(spanners = everything())
    )      
}
```


# Scientific notions

Units, superscripts, correct use of italics in species names. `{gt}` is fully compatible with markdown syntax and we will take advantage of it. We need to prepare the following:

- vs
- b
- ebwr

# Creation of a summary table


By family and country
```{r}
#| label: summarize-by-family-country

veg_summarized <- dat_vegetation |> 
    group_by(family, country, type) |>
    summarize(
        n_plants = n(),
        mean_d = mean(delta),
        sd_d = sd(delta),
        ) |> 
    ungroup()
```

## Minimal publication design

```{r}
#| label: tbl-publication-ready
#| tbl-cap: Mean delta 13 C values for selected C3 and C4 plant families

veg_summarized |> 
    gt() |>
    # this is only a helper column used for conditional formatting and it should not be displayed in the final table
    cols_hide("n_plants") |>
    # replace default NA values with a "-"
    # Note: modifying the data with {dplyr} functions would work equally well but {gt} has a devoted function for this purpose
    sub_missing(columns = "sd_d", missing_text = "-") |>
    tab_style(style = list(
        cell_text(style = "italic")),
    # family names in italics
    locations = cells_body(columns = "family")
    ) |> 
    # families with less than three measurements in grey
    tab_style(style = list(
        cell_text(color = "grey50")
    ),
    locations = cells_body(columns = everything(),
    rows = n_plants < 3)
    ) |> 
    # ^13^ is markdown for superscript, &delta is html for lower case Greek delta
    tab_spanner(columns = contains("_d"), label = md("&delta;^13^C")) |> 
    cols_label(
        family = "Family",
        country = "Country",
        type = "Type",
        mean_d = "Mean", 
        sd_d = "SD"
    ) |> 
    fmt_markdown(columns = c("type")) |> 
    fmt_number(columns = c("mean_d", "sd_d"), decimals = 2) |> 
    # basic formatting with the customized theme
    # Note: order matters here - the custom theme defines formatting for column spanners and it must be used only after a (all) spanner(s) were created
    paper_gt_theme() |> 
    # conditional formatting was introduced and it should be explained - a table footnote is a good place to do so
    tab_footnote(footnote = md(paste(folio_footnote, "<br>", 
                                  "Families which have less than three measurements are greyed out.")))
```


## Advanced design for stand-alone use

We want to catch attention, therefore we want to use more colours and we can also provide more details - *e.g.*, we can highlight countries in continent shapes.

```{r}
#| label: generate-continent-shapes
#| results: hide

# ------ Prepare countries  - contiennts data -------------------------------------------------
world_data <- ne_countries(scale = "medium", returnclass = "sf")
# head(world_data)

# ----- Identify countries and continents needed ----------------------------------------------

# Countries in the data
vegetation_countries <- unique(dat_vegetation$country)
vegetation_continents <- world_data[world_data$name_en %in% vegetation_countries, ]$continent

# Get their continents
vegetation_sf_continents <- world_data[world_data$continent %in% vegetation_continents, ]

# Subset the sf world data for countries of interest
vegetation_sf_countries <- world_data[world_data$name_en %in% vegetation_countries, ]

# ----- Plot continents with countries --------------------------------------------------------

# individual plots will be collected in this list
p_ls_countries <- list()

for (country in vegetation_countries) {
    # Countries with data on this continent
    target_continent <- vegetation_sf_countries[vegetation_sf_countries$name_en == country , ]$continent

    p_cont <- ggplot() +
        geom_sf(data = vegetation_sf_continents[vegetation_sf_continents$continent == target_continent, ], fill = "white") +
        geom_sf(data = vegetation_sf_countries[vegetation_sf_countries$name_en == country, ], fill = "blue") +
        theme_void()

    # save in the last, use country name as a label
    p_ls_countries[[country]] <- p_cont
}
```


```{r}
#| label: fxn-plot-country

# Functions inputs are:
# country - character vector with name of the country to be highlighted

# Function relies on:
# vegetation_sf_countries - a combined sf + data.frame object with country coordinates and details; based on data from the {rnaturalearth} package

PlotCountry <- function(target_country) {
  # Countries with data on this continent
  target_continent <- vegetation_sf_countries[vegetation_sf_countries$name_en == target_country, ]$continent
  
  country_label <- country_labels[names(country_labels) == target_country]

  p_cont <- ggplot() +
    geom_sf(data = vegetation_sf_continents[vegetation_sf_continents$continent == target_continent, ], fill = "white") +
    geom_sf(data = vegetation_sf_countries[vegetation_sf_countries$name_en == target_country, ], fill = "#1F6E5EFF") +
    labs(title = country_label) +
    theme_void() +
    theme(text = element_text(family = "serif"),
          plot.title = element_text(size = 24, hjust = 0.5))
  
  return(p_cont)
}
```


```{r}
#| label: fxn-plot-dot-violins

PlotHalfViolins <- function(data_to_plot) {
  p_halfv <- ggplot(data_to_plot, aes(x = country, y = delta)) +
    geom_violinhalf(colour = "#005C55FF", fill = "#005C55FF", position = position_nudge(x = 0.15, y = 0)) +
    geom_jitter(aes(fill = type), colour = "#005C55FF", alpha = 0.8, width = 0.05) +
    scale_y_continuous(breaks = c(-10, -20, -30, -40)) +
    coord_cartesian(ylim = c(-45, -10)) +
    theme_classic() +
    theme(
      plot.margin = margin(0, 0, 0, 0),
      plot.background = element_blank(),
      panel.background = element_blank(),
      axis.line.x = element_blank(),
      axis.line.y = element_line(colour = "black", linewidth = 1),
      axis.ticks.y = element_line(colour = "black", linewidth = 1),
      axis.ticks.x = element_blank(),
      axis.text.x = element_blank(),
      axis.text.y = element_text(colour = "black", size = 16),
      axis.title = element_blank(),
      aspect.ratio = 3,
      legend.position = "none"
    )

  return(p_halfv)
}
```


```{r}
#| label: set-custom-font

library(showtext) # fonts
font_add_google(name = "Open Sans", family = "open sans")
showtext_auto()
```


```{r}
#| label: tbl-advanced-design

summarized_tbl_input <- dat_vegetation |>
  group_by(country, type) |>
  summarize(mean_d = mean(delta)) |>
  mutate(violin_plot = country) |>
  arrange(country)

summarized_tbl_input |> 
  gt(
    id = "countries_tbl",
    rowname_col = "type",
    groupname_col = "country",
    row_group_as_column = T,
    process_md = T
  ) |>
  fmt_markdown(columns = "type") |>
  fmt_number(columns = "mean_d", decimals = 2) |>
  tab_spanner(columns = contains(c("mean", "violin")), label = md("&delta;^13^C")) |>
  cols_label(
    type = "Type",
    mean_d = "Mean",
    violin_plot = "Measurements"
  ) |>
  cols_align(align = "center", columns = everything()) |> 
  # country maps
  text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(y) {
        html(PlotCountry(y) |> ggplot_image(height = px(150), aspect_ratio = 1))
      })
    }
  ) |>
  # half violin + dot plots
  text_transform(
    locations = cells_body(columns = "violin_plot"),
    fn = function(x) {
      # Use `map2` to iterate over the column and the row index simultaneously
      map2(x, 1:length(x), function(col_value, i) {
        # Get the row-specific country and type from the summarized data
        target_country <- summarized_tbl_input$country[i]
        target_type <- summarized_tbl_input$type[i]

        # Filter the original data and create the plot
        data_to_plot <- dat_vegetation |>
          filter(country == !!target_country, type == !!target_type)

        PlotHalfViolins(data_to_plot) |>
          ggplot_image(height = px(200), aspect_ratio = 0.3) |>
          html()
      })
    }
  ) |>
  tab_style(
    style = list(
      cell_text(align = "center")
    ),
    locations = cells_body(columns = everything())
  ) |>
  tab_options(
    table.width = px(500),
    table.font.names = "open sans",
    heading.align = "center",
    column_labels.border.top.color = "white",
    column_labels.border.bottom.color = "white",
    heading.border.bottom.color = "white",
    table_body.border.top.color = "white",
    table_body.border.bottom.color = "white",
    table_body.hlines.color = "white",
    footnotes.border.bottom.color = "white"
  ) |>
  cols_width(
    type ~ px(100),
    mean_d ~ px(100)
  ) |> 
  opt_css(css ="
    #countries_tbl .gt_table {
      background: linear-gradient(180deg, #3F7F68, #DBD797);
    }
    
    #countries_tbl .gt_col_heading, #countries_tbl .gt_column_spanner_outer, #countries_tbl .gt_row.gt_center.gt_stub, #countries_tbl .gt_row.gt_center.gt_stub_row_group, #countries_tbl .gt_row.gt_left.gt_stub, #countries_tbl .gt_row.gt_left.gt_stub_row_group {
      background: transparent; border-right-style: none; vertical-align: middle;
    }") |>
  tab_footnote(md(folio_footnote))
```



## Interactive version

Maybe you want to draw attention to results of your project or an upcoming presentation. Social media are powerful and an interactive table might be a good option, for example on an institution website.

Sorting, search function

# Creation of an appendix table

Add ID to differentiate multiple specimens of the same species + location

```{r}
library(ggiraph)
```


```{r}
#| label: fxn-ggiraph-dot-violins

PlotGirafeViolins <- function(data_to_plot){
  p_violin <- ggplot(data_to_plot, aes(x = country, y = delta)) +
    geom_violin(colour = "#005C55FF", fill = "#005C55FF", alpha = 0.25) +
    geom_jitter_interactive(aes(tooltip = species), colour = "#005C55FF") +
    scale_y_continuous(breaks = c(-10, -20, -30, -40)) +
    coord_cartesian(ylim = c(-45, -10)) +
    theme_classic() +
    theme(
      plot.margin = margin(0, 0, 0, 0),
      panel.background = element_rect(
        fill = "transparent",
        colour = NA_character_
      ),
      plot.background = element_rect(
        fill = "transparent",
        colour = NA_character_
      ),
      axis.line.x = element_blank(),
      axis.line.y = element_line(colour = "black", linewidth = 1),
      axis.ticks.y = element_line(colour = "black", linewidth = 1),
      axis.ticks.x = element_blank(),
      axis.text.x = element_blank(),
      axis.text.y = element_text(colour = "black", size = 16),
      axis.title = element_blank(),
      aspect.ratio = 3,
      legend.position = "none"
    )

  g_violin <- girafe(
    ggobj = p_violin,
    width_svg = 2,
    height_svg = 3.5
  ) |>
    girafe_options(
      opts_tooltip(css = "background-color: white; text-color: black; font-style: italic;")
    )

  # Save the ggiraph plot to a temporary HTML file
  tmpfile <- tempfile(fileext = ".html")
  save_html(g_violin, tmpfile)

  # Read the content of the HTML file as a single character string
  plot_html_content <- paste(readLines(tmpfile, warn = FALSE), collapse = "\n")

  return(plot_html_content)
}
```



## Interactive table

```{r}
library(htmltools)
```


```{r}
#| label: tbl-advanced-ggiraph

gt_giraph <- summarized_tbl_input |> 
  gt(
    id = "countries_tbl",
    rowname_col = "type",
    groupname_col = "country",
    row_group_as_column = T,
    process_md = T
  ) |>
  fmt_markdown(columns = "type") |>
  fmt_number(columns = "mean_d", decimals = 2) |>
  tab_spanner(columns = contains(c("mean", "violin")), label = md("&delta;^13^C")) |>
  cols_label(
    type = "Type",
    mean_d = "Mean",
    violin_plot = "Measurements"
  ) |>
  cols_align(align = "center", columns = everything()) |> 
  # country maps
  text_transform(
    locations = cells_row_groups(),
    fn = function(x) {
      lapply(x, function(y) {
        html(PlotCountry(y) |> ggplot_image(height = px(150), aspect_ratio = 1))
      })
    }
  ) |> 
  # Corrected text_transform
  text_transform(
    locations = cells_body(columns = "violin_plot"),
    fn = function(x) {
      lapply(1:length(x), function(i) {
        target_country <- summarized_tbl_input$country[i]
        target_type <- summarized_tbl_input$type[i]

        data_to_plot <- dat_vegetation |>
          filter(country == target_country, type == target_type)

        # Call the modified plotting function and wrap in html()
        PlotGirafeViolins(data_to_plot) |>
          html()
      })
    }
  ) |> 
  tab_style(
    style = list(
      cell_text(align = "center")
    ),
    locations = cells_body(columns = everything())
  ) |>
  tab_options(
    table.width = px(500),
    table.font.names = "open sans",
    heading.align = "center",
    column_labels.border.top.color = "white",
    column_labels.border.bottom.color = "white",
    heading.border.bottom.color = "white",
    table_body.border.top.color = "white",
    table_body.border.bottom.color = "white",
    table_body.hlines.color = "white",
    footnotes.border.bottom.color = "white"
  ) |>
  cols_width(
    type ~ px(100),
    mean_d ~ px(100)
  ) |> 
  opt_css(css ="
    #countries_tbl .gt_table {
      background: linear-gradient(180deg, #3F7F68, #DBD797);
    }
    
    #countries_tbl .gt_col_heading, #countries_tbl .gt_column_spanner_outer, #countries_tbl .gt_row.gt_center, #countries_tbl .gt_row.gt_center.gt_stub_row_group, #countries_tbl .gt_row.gt_left.gt_stub, #countries_tbl .gt_row.gt_left.gt_stub_row_group, #countries_tbl .ggiraph-svg, #countries-tbl .girafe_container {
      background: transparent; border-right-style: none; vertical-align: middle;
    }") |>
  tab_footnote(md(folio_footnote))

final_html_output <- as_raw_html(gt_giraph,
  inline_css = TRUE
)

write(final_html_output, "interactive_table.html")
```




# Resources

Besides package documentation, I found the following resources useful:
- [https://rfortherestofus.com/2023/08/table-theme-gt](https://rfortherestofus.com/2023/08/table-theme-gt)   
- https://gt.albert-rapp.de/fancy_stuff#add-arbitrary-plots-to-your-table  
- https://gt.albert-rapp.de/styling#tab-options
- sPBIYlGn colour palette (https://r-graph-gallery.com/color-palette-finder)
- Google Gemini for embeding of girafe objects into a gt table
